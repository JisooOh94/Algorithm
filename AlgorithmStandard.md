# ***Algorithm Standart***

* 일반적인 경우에 for-loop 중첩이 recursion 보다 속도 측면에서 더 효율적이다.
* Recursion 을 사용한다면 최대한 back-tracking 을 적용하여 불필요한 객체 생성을 최소화한다.
* 입력샘플이 null 이거나 비어있거나, valid 하지 않은경우의 가지치기는 항상 수행해준다.
* 최대한 가능한 모든 가지치기를 수행하여 loop 횟수를 최소하해준다. 
* 효율적인 알고리즘 솔루션을 생각해내는것보다 브루트포스 + 자잘한 가지치기를 수행해주는것이 성능 및 소요시간 측면에서 더 효율적일 수 있다.
* 넘치는 배열 객체 생성후 Direct Access 하는것보다 딱 맞는 LinkedList 생성 후 Sequentail access 하는것이 더 효율적이다.
* 우선순위 큐(PriorityQueue)에서 큐 내의 요소 수가 적을수록 offer 속도가 빨라진다.(불필요한 요소는 삭제 - K Closest Points to Origin)
* 생각보다 객체 생성 비용은 필드가 1개뿐이어도 비싸다
* 생각보다 Hashing 비용은 비싸다. Map 에 추가될 element 수를 판단하여 메모리에 부담이 없다면, array 로 대체하는것이 더 효율적이다.
* 조금의 비효율이나 중복이 있더라고 간결한 로직이 비효율을 제거하기 위해 이것저것 추가하는것보다 보통 더 효율적이다
    * 객체 생성이나 배열 생성하는 솔루션이 최선의 솔루션일때도 많다.
* 일반적으로 효율적인 솔루션이 떠오르지 않을떈, 비효율적이라 생각된 시뮬레이션 솔루션이 최선의 선택인 경우가 많다.
* Comparator 정의시 ```(e1, e2) -> e1 - e_2``` 와 ```(e1, e2) -> e1 > e2 ? 1 : e1 < e2 ? -1 : 0``` 동일