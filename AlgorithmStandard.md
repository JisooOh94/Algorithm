# ***Algorithm Standart***
* 일반적인 경우에 for-loop 중첩이 recursion 보다 속도 측면에서 더 효율적이다.
* Recursion 을 사용한다면 최대한 back-tracking 을 적용하여 불필요한 객체 생성을 최소화한다.
* 입력샘플이 null 이거나 비어있거나, valid 하지 않은경우의 가지치기는 항상 수행해준다.
* 최대한 가능한 모든 가지치기를 수행하여 loop 횟수를 최소하해준다. 
* 효율적인 알고리즘 솔루션을 생각해내는것보다 브루트포스 + 자잘한 가지치기를 수행해주는것이 성능 및 소요시간 측면에서 더 효율적일 수 있다.
* 넘치는 배열 객체 생성후 Direct Access 하는것보다 딱 맞는 LinkedList 생성 후 Sequentail access 하는것이 더 효율적이다.
* 우선순위 큐(PriorityQueue)에서 큐 내의 요소 수가 적을수록 offer 속도가 빨라진다.(불필요한 요소는 삭제 - K Closest Points to Origin)
* 생각보다 객체 생성 비용은 필드가 1개뿐이어도 비싸다
* 생각보다 Hashing 비용은 비싸다. Map 에 추가될 element 수를 판단하여 메모리에 부담이 없다면, array 로 대체하는것이 더 효율적이다.
* 조금의 비효율이나 중복이 있더라고 간결한 로직이 비효율을 제거하기 위해 이것저것 추가하는것보다 보통 더 효율적이다
    * 객체 생성이나 배열 생성하는 솔루션이 최선의 솔루션일때도 많다.
* 일반적으로 효율적인 솔루션이 떠오르지 않을떈, 비효율적이라 생각된 시뮬레이션 솔루션이 최선의 선택인 경우가 많다.
* Comparator 정의시 ```(e1, e2) -> e1 - e_2``` 와 ```(e1, e2) -> e1 > e2 ? 1 : e1 < e2 ? -1 : 0``` 동일
* 자료구조(List, Set 등..) 사용시 참조변수 또한 구현체 클래스타입으로 선언

### DP
* 일반적으로 bottom-up dp 가 top-down dp 보다 성능이 더 뛰어나다.
* 재귀 함수 내에서 for문 사용하는 지양해야한다. for 문은 재귀로 풀어낼 수 있다.

<br>

# ***google roadmap***
### 문제집
* leetcode
* baekjoon
* COCI (백준에 번역 문제 존재)
* 코딩 인터뷰 완전 분석

### Clean Code
* 뇌디버깅을 통해 오류 없는 코드 작성
* 코드 작성시, SOLID 원칙 및 가독성 신경써가며 개발
* 함수, 변수명은 최대한 구체적으로 명명
* 로직이 복잡해진다면, 주석으로 설명 추가
* 다른사람의 코드를 참고해 가독성 개선
* 작성한 코드를 2주뒤에 한눈에 다시 봐도 이해할 수 있는지 검증 

### 문제풀이 방식
1. 받은 문제를 간략하게 요약 및 조건, 유의해야할 부분 정리
  * 코너 케이스, 데이터 타입 크기 등등
2. 접근할 방식 정리 및 예상 시간복잡도 계산
  * 브르투 포스부터 시작해서 알고리즘 풀이의 핵심인 중복되는 작업을 줄여나가는 식으로 풀이
  * 접근 방법이 45분 이상 떠오르지 않는다면 바로 포기 후 풀이를 보며 학습
  * 면접관에게 설명하는 것처럼 complexity와 풀이 방향을 주석으로 적은 다음에 구현 시작
3. 코드 작성 후, 코너케이스를 포함한 테스트 케이스로 뇌내 테스트
4. 내 솔루션이 optimal 하지 않다면, 다른사람들의 optimal 솔루션 학습, 접근 방법 정리 및 재시도
  * 옵티멀 솔루션 도출 및 도출 과정 까지의 생각의 흐름을 영어로 말하는 연습
5. 내 솔루션이 optimal 해도, 다른사람들의 솔루션을 보며 다른 접근법 학습

### 영어
* 기술 관련 정보 영어 듣기로 이해하기 연습
  * 미국 테크 유튜버 (TechLead, Clément Mihailescu)
* 알고리즘 문제를 영어로 풀이 설명하면서 푸는 연습

### 실전
1. 머리 속에 든 내용을 말로 하는 연습을 하세요.
  * 진짜 사소한 디테일이라도 다 얘기하는게 중요해요. 5초 이상 침묵이 지속되면 red flag에요. 만약 생각할 시간이 몇 초간 필요하면 인터뷰어에게 몇 초간 생각하면서 침묵해도 되는지 물어보고 진행하세요.
2. 계속 확인하세요.
  * 1번과 이어지는 내용인데 여러분이 생각한걸 무조건 맞다고 생각하지 마시고 중간 중간에 인터뷰어가 잘 따라오고 있는지 확인하세요. 페어 프로그래밍한다고 생각하고 여러분이 생각하신 내용을 상대방도 동의하는지 확인하면 돼요. 간단하게 하나 정하고 나면 Does it make sense to you? What do you think? 이런식으로 추임새를 주면 되겠죠.
3. 힌트를 요구하세요.
  * 못 풀고 헤매고 있으면 인터뷰어가 힌트를 주기 시작할텐데 그래도 모르겠다면 시간을 아끼기 위해서 대놓고 물어보세요. 물론 혼자 힘으로 못 풀었으니 감점이 되겠지만 아예 손도 못대는거보다 나아요. 저도 한 라운드는 그냥 대놓고 물어봤어요.
4. 로직이 반복되면 helper 함수 만들어서 abstract하세요.
  * 저는 수도 코드 만들 때 로직이 나눌 수 있으면 설명만 적어두고 나중에 구현할 때 따로 함수 만들어서 적용했어요. 이거도 습관이랑 관련된거니까 알고리즘 연습할 때 계속 연습해두세요.
5. 생략할 수 있는건 생략하세요.
  * 간혹 문제에서 잘 알려진 로직이나 수학적인 공식을 구현해야 되는 경우가 있어요. 예를 들면 바이너리 서치나 길이를 구하는 함수를 구현해야 된다면 인터뷰어한테 그냥 구현했다고 가정하고 함수명만 이용해서 	풀어도 되는지 물어보세요. 중요한 부분이 아니라면 그렇게 하자라고 할거에요.

### Reference
https://norang.io/diary/interview_review/
https://benguin.tistory.com/2
https://daily-foreign-worker.tistory.com/21
https://velog.io/@gomjellie/%EA%B5%AC%EA%B8%80-%EC%BD%94%EB%A6%AC%EC%95%84-%EB%A9%B4%EC%A0%91%ED%9B%84%EA%B8%B0
https://heejungryu.tistory.com/entry/%ED%95%B4%EC%99%B8-%EC%9C%A0%ED%95%99%EC%83%9D-%ED%95%B4%EC%99%B8%EC%82%AC-%EC%9E%85%EC%82%AC-%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-%EB%85%B8%ED%95%98%EC%9A%B0?category=406946
https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220769859177&navType=by